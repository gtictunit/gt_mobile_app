"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyStyles = applyStyles;
exports.borderStyleNames = void 0;
exports.extractBorderAndMarginStyles = extractBorderAndMarginStyles;
exports.extractStyles = extractStyles;
exports.getValueForRadioButton = getValueForRadioButton;
exports.marginStyleNames = void 0;

var _reactNative = require("react-native");

var _lodash = require("lodash");

function extractStyles(style) {
  const {
    color,
    fontFamily,
    fontWeight,
    fontSize,
    lineHeight,
    letterSpacing,
    textTransform,
    textAlign,
    textDecorationLine,
    textDecorationColor,
    textDecorationStyle,
    ...viewStyles
  } = _reactNative.StyleSheet.flatten(style || {});

  const textStyles = {
    color,
    fontFamily,
    fontWeight,
    fontSize,
    lineHeight,
    letterSpacing,
    textTransform,
    textAlign,
    textDecorationLine,
    textDecorationColor,
    textDecorationStyle
  };
  return {
    viewStyles,
    textStyles
  };
}

const borderStyleNames = ["borderRadius", "borderBottomColor", "borderBottomEndRadius", "borderBottomLeftRadius", "borderBottomRightRadius", "borderBottomStartRadius", "borderBottomWidth", "borderColor", "borderEndColor", "borderLeftColor", "borderLeftWidth", "borderRadius", "borderRightColor", "borderRightWidth", "borderStartColor", "borderStyle", "borderTopColor", "borderTopEndRadius", "borderTopLeftRadius", "borderTopRightRadius", "borderTopStartRadius", "borderTopWidth", "borderWidth"];
exports.borderStyleNames = borderStyleNames;
const marginStyleNames = ["margin", "marginBottom", "marginEnd", "marginHorizontal", "marginLeft", "marginRight", "marginStart", "marginTop", "marginVertical"];
exports.marginStyleNames = marginStyleNames;

function extractBorderAndMarginStyles(style, additionalBorderStyles, additionalMarginStyles) {
  const flatStyle = _reactNative.StyleSheet.flatten(style || {});

  const borderStyles = (0, _lodash.pickBy)((0, _lodash.pick)(flatStyle, [...borderStyleNames, ...(additionalBorderStyles ? additionalBorderStyles : [])]), _lodash.identity);
  const marginStyles = (0, _lodash.pickBy)((0, _lodash.pick)(flatStyle, [...marginStyleNames, ...(additionalMarginStyles ? additionalMarginStyles : [])]), _lodash.identity);
  return {
    borderStyles,
    marginStyles
  };
}
/**
 * Merges a style object on top of another style object. In React Native,
 * keys with undefined values in a style object will still override styles
 * that appear earlier in a sequence. This avoids that problem.
 *
 * This lets us avoid the `...(something ? { something } : {})` pattern.
 * There doesn't seem to be a better way to do this. These all seem to not
 * work (i.e. they all result in `{ color: undefined }`:
 * `const mergedStyles = [{ color: "red" }, { color: undefined }]`
 * `const mergedStyles = StyleSheet.compose({ color: "red" }, { color: undefined })`
 * `const mergedStyles = StyleSheet.flatten([{ color: "red" }, { color: undefined }])`
 */


function applyStyles(baseStyles, stylesToApply) {
  if (!stylesToApply) {
    return;
  }

  const flattenedStyles = _reactNative.StyleSheet.flatten(baseStyles);

  for (const [key, value] of Object.entries(stylesToApply)) {
    if (value != null) {
      flattenedStyles[key] = value;
    }
  }

  return flattenedStyles;
}

function getValueForRadioButton(value) {
  if ((0, _lodash.isString)(value)) {
    return value;
  } else if ((0, _lodash.isNumber)(value)) {
    return String(value);
  } else {
    throw new Error("Invalid value: ".concat(value));
  }
}
//# sourceMappingURL=utilities.js.map