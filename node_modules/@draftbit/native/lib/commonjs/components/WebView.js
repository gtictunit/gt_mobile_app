"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _reactNativeWebview = require("react-native-webview");

var _expoCamera = require("expo-camera");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// Auto-height fix (if this is not present, scrolling on Android does not work)
const injectFirst = "\n  window.ReactNativeWebView.postMessage(\n    Math.max(document.body.offsetHeight, document.body.scrollHeight)\n  );\n";

const NativeWebView = _ref => {
  let {
    source,
    style,
    optimizeVideoChat,
    ...otherWebViewProps
  } = _ref;
  const [height, setHeight] = (0, _react.useState)(0);
  const [cameraPermissions, setCameraPermissions] = (0, _react.useState)(null);
  const [microphonePermissions, setMicrophonePermissions] = (0, _react.useState)(null);
  const videoChatProps = optimizeVideoChat ? {
    allowsInlineMediaPlayback: true,
    domStorageEnabled: true,
    javaScriptEnabled: true,
    mediaCapturePermissionGrantType: "grant",
    // so iOS uses system settings
    mediaPlaybackRequiresUserAction: false,
    startInLoadingState: true
  } : {};

  const onMessage = event => setHeight(Number(event.nativeEvent.data));

  const getAndSetPermissions = async (currentState, setCurrentState, getPermission, requestPermission) => {
    const currentPermission = currentState !== null && currentState !== void 0 ? currentState : await getPermission();

    if (currentPermission.granted || !currentPermission.canAskAgain) {
      setCurrentState(currentPermission);
    } else {
      setCurrentState(await requestPermission());
    }
  };

  const getAndSetCameraAndMicrophonePermissions = async () => {
    await getAndSetPermissions(cameraPermissions, setCameraPermissions, _expoCamera.Camera.getCameraPermissionsAsync, _expoCamera.Camera.requestCameraPermissionsAsync);
    await getAndSetPermissions(microphonePermissions, setMicrophonePermissions, _expoCamera.Camera.getMicrophonePermissionsAsync, _expoCamera.Camera.requestMicrophonePermissionsAsync);
  };

  const getFinalWidth = () => {
    const {
      width
    } = _reactNative.Dimensions.get("window");

    if (typeof (style === null || style === void 0 ? void 0 : style.width) === "number") {
      return style.width;
    } else if (typeof (style === null || style === void 0 ? void 0 : style.width) === "string" && style.width.includes("%")) {
      return width * (Number(style.width.replace("%", "")) / 100);
    } else {
      return width;
    }
  };

  const selectComponent = () => {
    if (!optimizeVideoChat || cameraPermissions !== null && cameraPermissions !== void 0 && cameraPermissions.granted && microphonePermissions !== null && microphonePermissions !== void 0 && microphonePermissions.granted) {
      return /*#__PURE__*/_react.default.createElement(_reactNativeWebview.WebView, _extends({
        source: source,
        style: { ...style,
          width: getFinalWidth()
        },
        injectedJavaScript: injectFirst,
        onMessage: onMessage
      }, otherWebViewProps, videoChatProps));
    }

    if (!(cameraPermissions !== null && cameraPermissions !== void 0 && cameraPermissions.granted) && cameraPermissions !== null && cameraPermissions !== void 0 && cameraPermissions.canAskAgain || !(microphonePermissions !== null && microphonePermissions !== void 0 && microphonePermissions.granted) && microphonePermissions !== null && microphonePermissions !== void 0 && microphonePermissions.canAskAgain) {
      return /*#__PURE__*/_react.default.createElement(_reactNative.Button, {
        title: "Press to enable Audio and/or Video permissions",
        onPress: getAndSetCameraAndMicrophonePermissions
      });
    }

    if ((cameraPermissions === null || cameraPermissions === void 0 ? void 0 : cameraPermissions.status) === "denied" && (cameraPermissions === null || cameraPermissions === void 0 ? void 0 : cameraPermissions.canAskAgain) === false || (microphonePermissions === null || microphonePermissions === void 0 ? void 0 : microphonePermissions.status) === "denied" && (microphonePermissions === null || microphonePermissions === void 0 ? void 0 : microphonePermissions.canAskAgain) === false) {
      return /*#__PURE__*/_react.default.createElement(_reactNative.Text, null, "Set the missing Audio and/or Video permissions in System Settings");
    }

    return /*#__PURE__*/_react.default.createElement(_reactNative.ActivityIndicator, null);
  };

  (0, _react.useEffect)(() => {
    if (optimizeVideoChat) getAndSetCameraAndMicrophonePermissions(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [optimizeVideoChat]);
  return /*#__PURE__*/_react.default.createElement(_reactNative.ScrollView, {
    contentContainerStyle: [styles.container, {
      height: (style === null || style === void 0 ? void 0 : style.height) || height
    }]
  }, selectComponent());
};

const BrowserWebView = _ref2 => {
  let {
    source,
    style,
    optimizeVideoChat
  } = _ref2;
  const videoChatProps = optimizeVideoChat ? {
    frameBorder: "0",
    allow: "camera; microphone; fullscreen; speaker; display-capture"
  } : {};
  const videoChatStyles = optimizeVideoChat ? {
    width: "100%",
    height: "100%"
  } : {};

  const flatStyles = _reactNative.StyleSheet.flatten([videoChatStyles, style]);

  return /*#__PURE__*/_react.default.createElement("iframe", {
    style: flatStyles,
    height: flatStyles === null || flatStyles === void 0 ? void 0 : flatStyles.height,
    width: flatStyles === null || flatStyles === void 0 ? void 0 : flatStyles.width,
    src: source === null || source === void 0 ? void 0 : source.uri,
    srcDoc: source === null || source === void 0 ? void 0 : source.html,
    allowFullScreen: true,
    seamless: true,
    ...videoChatProps
  });
};

var _default = _reactNative.Platform.select({
  native: NativeWebView,
  default: BrowserWebView
});

exports.default = _default;

const styles = _reactNative.StyleSheet.create({
  container: {
    flexGrow: 1,
    alignItems: "center",
    justifyContent: "center"
  }
});
//# sourceMappingURL=WebView.js.map